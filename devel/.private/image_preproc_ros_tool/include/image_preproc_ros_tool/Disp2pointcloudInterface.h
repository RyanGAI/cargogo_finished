// *********************************************************
//
// File autogenerated for the image_preproc_ros_tool package
// by the rosinterface_handler package.
// Please do not edit.
//
// ********************************************************/

#pragma once

#include <stdlib.h>
#include <string>
#include <limits>
#include <memory>
#include <ros/param.h>
#include <ros/node_handle.h>
#include <rosinterface_handler/utilities.hpp>
#ifdef MESSAGE_FILTERS_FOUND
#include <message_filters/subscriber.h>

#else

#endif
#ifdef DYNAMIC_RECONFIGURE_FOUND
#include <image_preproc_ros_tool/Disp2pointcloudConfig.h>
#else
struct Disp2pointcloudConfig{};
#endif


namespace image_preproc_ros_tool {

/// \brief Parameter struct generated by rosinterface_handler
struct Disp2pointcloudInterface {

  using Config = Disp2pointcloudConfig;
#ifdef MESSAGE_FILTERS_FOUND
  template<typename T>
  using Subscriber = message_filters::Subscriber<T>;
  template<typename T>
  using SubscriberPtr = std::shared_ptr<Subscriber<T>>;
#endif
#ifdef IF_HANDLER_DIAGNOSTICS_INCLUDED
  template<typename T>
  using DiagSubscriber = rosinterface_handler::DiagnosedSubscriber<T>;
  template<typename T>
  using DiagSubscriberPtr = std::shared_ptr<DiagSubscriber<T>>;
  template<typename T>
  using DiagPublisher = rosinterface_handler::DiagnosedPublisher<T>;
#endif

  Disp2pointcloudInterface(const ros::NodeHandle& private_node_handle)
  : globalNamespace_{"/"},
    publicNamespace_{rosinterface_handler::getParentNamespace(private_node_handle) + "/"},
    privateNamespace_{private_node_handle.getNamespace() + "/"},
    nodeName_{rosinterface_handler::getNodeName(private_node_handle)},
    privateNodeHandle_{private_node_handle} {}

  /// \brief Get values from parameter server
  ///
  /// Will fail if a value can not be found and no default value is given.
  void fromParamServer(){
    bool success = true;
    success &= rosinterface_handler::getParam(privateNamespace_ + "msg_queue_size", msg_queue_size, int{5});
    success &= rosinterface_handler::getParam(privateNamespace_ + "verbosity", verbosity, std::string{"info"});
    rosinterface_handler::testConstParam(privateNamespace_ + "verbosity_debug");
    rosinterface_handler::testConstParam(privateNamespace_ + "verbosity_info");
    rosinterface_handler::testConstParam(privateNamespace_ + "verbosity_warning");
    rosinterface_handler::testConstParam(privateNamespace_ + "verbosity_error");
    rosinterface_handler::testConstParam(privateNamespace_ + "verbosity_fatal");
    success &= rosinterface_handler::getParam(privateNamespace_ + "base_path", base_path, std::string{"in_topic"});
    success &= rosinterface_handler::getParam(privateNamespace_ + "image_topic", image_topic, std::string{"image"});
    success &= rosinterface_handler::getParam(privateNamespace_ + "disp_topic", disp_topic, std::string{"disp"});
    success &= rosinterface_handler::getParam(privateNamespace_ + "pointcloud_topic", pointcloud_topic, std::string{"pointcloud"});
    success &= rosinterface_handler::getParam(privateNamespace_ + "info_topic", info_topic, std::string{"camera_info"});
    success &= rosinterface_handler::getParam(privateNamespace_ + "invalid_value", invalid_value, int{-1});
    success &= rosinterface_handler::getParam(privateNamespace_ + "remap_in", remap_in);
    success &= rosinterface_handler::getParam(privateNamespace_ + "remap_out", remap_out);
    success &= rosinterface_handler::getParam(privateNamespace_ + "mask", mask, std::string{""});
    success &= rosinterface_handler::getParam(privateNamespace_ + "base_width", base_width, double{-1});
    success &= rosinterface_handler::getParam(privateNamespace_ + "focal_length", focal_length, double{-1});
    rosinterface_handler::setLoggerLevel(privateNodeHandle_, "verbosity");



    rosinterface_handler::testMin<int>(privateNamespace_ + "msg_queue_size", msg_queue_size, 1);
    rosinterface_handler::testMin<int>(privateNamespace_ + "invalid_value", invalid_value, -1);
    rosinterface_handler::testMax<int>(privateNamespace_ + "invalid_value", invalid_value, 255);
    if(!success){
      missingParamsWarning();
      rosinterface_handler::exit("RosinterfaceHandler: GetParam could net retrieve parameter.");
    }
    ROS_DEBUG_STREAM(*this);
  }

  /// \brief Set parameters on ROS parameter server.
  void toParamServer(){
    rosinterface_handler::setParam(privateNamespace_ + "msg_queue_size",msg_queue_size);
    rosinterface_handler::setParam(privateNamespace_ + "verbosity",verbosity);
    rosinterface_handler::setParam(privateNamespace_ + "base_path",base_path);
    rosinterface_handler::setParam(privateNamespace_ + "image_topic",image_topic);
    rosinterface_handler::setParam(privateNamespace_ + "disp_topic",disp_topic);
    rosinterface_handler::setParam(privateNamespace_ + "pointcloud_topic",pointcloud_topic);
    rosinterface_handler::setParam(privateNamespace_ + "info_topic",info_topic);
    rosinterface_handler::setParam(privateNamespace_ + "invalid_value",invalid_value);
    rosinterface_handler::setParam(privateNamespace_ + "remap_in",remap_in);
    rosinterface_handler::setParam(privateNamespace_ + "remap_out",remap_out);
    rosinterface_handler::setParam(privateNamespace_ + "mask",mask);
    rosinterface_handler::setParam(privateNamespace_ + "base_width",base_width);
    rosinterface_handler::setParam(privateNamespace_ + "focal_length",focal_length);
  }

  /// \brief Update configurable parameters.
  ///
  /// \param config  dynamic reconfigure struct
  /// \level ?
  void fromConfig(const Config& config, const uint32_t level = 0){
#ifdef DYNAMIC_RECONFIGURE_FOUND

    if(config.verbosity != this->verbosity) {
        rosinterface_handler::setParam(privateNamespace_ + "verbosity", config.verbosity);
        rosinterface_handler::setLoggerLevel(privateNodeHandle_, "verbosity");
    }
    verbosity = config.verbosity;
    invalid_value = config.invalid_value;
    base_width = config.base_width;
    focal_length = config.focal_length;
#else
  ROS_FATAL_STREAM("dynamic_reconfigure was not found during compilation. So fromConfig() is not available. Please recompile with dynamic_reconfigure.");
  rosinterface_handler::exit("dynamic_reconfigure was not found during compilation. So fromConfig() is not available. Please recompile with dynamic_reconfigure.");
#endif
  }

  /// \brief Stream operator for printing parameter struct
  friend std::ostream& operator<<(std::ostream& os, const Disp2pointcloudInterface& p)
  {
    os << "[" << p.nodeName_ << "]\nNode " << p.nodeName_ << " has the following parameters:\n"
      << "	" << p.privateNamespace_ << "msg_queue_size:" << p.msg_queue_size << "\n"
      << "	" << p.privateNamespace_ << "verbosity:" << p.verbosity << "\n"
      << "	" << p.privateNamespace_ << "verbosity_debug:" << p.verbosity_debug << "\n"
      << "	" << p.privateNamespace_ << "verbosity_info:" << p.verbosity_info << "\n"
      << "	" << p.privateNamespace_ << "verbosity_warning:" << p.verbosity_warning << "\n"
      << "	" << p.privateNamespace_ << "verbosity_error:" << p.verbosity_error << "\n"
      << "	" << p.privateNamespace_ << "verbosity_fatal:" << p.verbosity_fatal << "\n"
      << "	" << p.privateNamespace_ << "base_path:" << p.base_path << "\n"
      << "	" << p.privateNamespace_ << "image_topic:" << p.image_topic << "\n"
      << "	" << p.privateNamespace_ << "disp_topic:" << p.disp_topic << "\n"
      << "	" << p.privateNamespace_ << "pointcloud_topic:" << p.pointcloud_topic << "\n"
      << "	" << p.privateNamespace_ << "info_topic:" << p.info_topic << "\n"
      << "	" << p.privateNamespace_ << "invalid_value:" << p.invalid_value << "\n"
      << "	" << p.privateNamespace_ << "remap_in:" << p.remap_in << "\n"
      << "	" << p.privateNamespace_ << "remap_out:" << p.remap_out << "\n"
      << "	" << p.privateNamespace_ << "mask:" << p.mask << "\n"
      << "	" << p.privateNamespace_ << "base_width:" << p.base_width << "\n"
      << "	" << p.privateNamespace_ << "focal_length:" << p.focal_length << "\n"
;
    return os;
  }

  /// \brief get the node handle that the interface struct uses internally
  ros::NodeHandle getPrivateNodeHandle() {
      return privateNodeHandle_;
  }

  /// \brief returns the name of the node (works in nodelets, too)
  const std::string& nodeName() {
      return nodeName_;
  }
private:
  const std::string globalNamespace_;
  const std::string publicNamespace_;
  const std::string privateNamespace_;
  const std::string nodeName_;
  ros::NodeHandle privateNodeHandle_;

public:
  int msg_queue_size; /*!< Queusize for publisher */
  std::string verbosity; /*!< Sets the verbosity for this node */
  static constexpr auto verbosity_debug = "debug"; /*!< Constant for enum verbosity */
  static constexpr auto verbosity_info = "info"; /*!< Constant for enum verbosity */
  static constexpr auto verbosity_warning = "warning"; /*!< Constant for enum verbosity */
  static constexpr auto verbosity_error = "error"; /*!< Constant for enum verbosity */
  static constexpr auto verbosity_fatal = "fatal"; /*!< Constant for enum verbosity */
  std::string base_path; /*!< Path to the topic containing the image_topic and the disp_topic */
  std::string image_topic; /*!< Name of the image topic */
  std::string disp_topic; /*!< Name of the disparity topic */
  std::string pointcloud_topic; /*!< Name of the output pointcloud */
  std::string info_topic; /*!< Name of the camera info topic */
  int invalid_value; /*!< Value in image to be seen as invalid (negative means inactive) */
  std::vector<int> remap_in; /*!< Map intensiy values (input), must be same size as output */
  std::vector<int> remap_out; /*!< Map intensiy values (output), must be same size as input */
  std::string mask; /*!< Path to a mask of same size as input image */
  double base_width; /*!< Overwrite base_width */
  double focal_length; /*!< Overwrite focal length */



private:
  /// \brief Issue a warning about missing default parameters.
  void missingParamsWarning(){
    ROS_WARN_STREAM("[" << nodeName_ << "]\nThe following parameters do not have default values and need to be specified:\n"
      << "	" << privateNamespace_ << "remap_in" << " (std::vector<int>) \n"
      << "	" << privateNamespace_ << "remap_out" << " (std::vector<int>) \n"
    );
  }
};

} // namespace image_preproc_ros_tool
